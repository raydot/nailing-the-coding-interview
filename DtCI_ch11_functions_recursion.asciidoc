[[DtCI_ch11]]

== Functions and Recursion

After reading this chapter the reader should know how to use both recursive and non-recursive functions, how to reason about functions, and what type of functions problems to expect on a coding test.

=== Functions 101

=== You will be asked a question about functions

While there are many ways to define and describe functions I've never heard one more accurate than "functions are the building blocks of code."  
Functions are a primary and essential part of coding that you should absolutely expect to use in a coding interview. 
Even if you're not asked a question about functions directly, you will almost certainly need to use a function to solve a harder problem.

=== What is a function?
Functions are usually the first "advanced" things a programmer learns.
Functions in programming are similar to the function equations you may have learned in high school algebra, which looked something like this:

f(x) = 2x

Learning about functions often included exercises to create tables of the expected results.  The table for f(x) = 2x might look like this:

[cols="1,1"]
|===
|x|f(x)

|1
|2

|2
|4

|3
|6
|===

Functions in programming perform a similar, um, function, allowing data passed in to be transformed in a way specified by the programmer.  
Here is the above-mentioned example high-school algebra function in Python:

[source, python]
----
def doubler-function(value):
  return (2 * value)
----

Function implementations are language-specific, with C++ and Java requiring functions be set to data types, and JavaScript containing several ways to create functions, depending on what you're trying to accomplish.
In every language, however, functions are just like the ones you encountered in high-school algebra.
They take a value (or values), transform them according to a set of rules, and return the result.

=== Building Intuition: Reasoning about functions

=== Functions basics

=== Function prototypes
In strongly typed languages, functions are usually defined by a _prototype_, a block of code that defines the function in terms of the data it can expect to receive and return. 
In this way, function prototypes are used to enforce type checking, to make sure that the values that are being passed to a function are what it expects to receive.
This is an example function prototype in C:

[source, c]
----
// Function prototype
float multIntAndFloat(int num1, float num2);
----

The first `float` in this prototype indicates that it will return a float.
The `int` and `float` keywords preceding the two values being passed in means these values _must_ be an int and a float.
If you pass or return any other type of data, the compiler will return an error -- or at least a warning, depending on the C implementation you're using.

Weakly typed languages don't require function prototypes, but there are ways to require them, of course.
The Typescript programming language is probably the best current example of creating type-checking, for all data and not just functions, in JavaScript.

TIP: Try coming up with examples of situations in which it would be important to check data passed to a function.
Are the checks limited to checking data types?
If your language doesn't support function prototyping, how can data checks in functions be enforced?

=== Constructing functions

=== Receiving function data

=== Returning function data

=== Closures

=== Functions Advanced

=== The mystical “this”

=== Constructor functions

=== Generator functions

=== Function chaining

=== Side effects and functional programming

=== Currying

=== Higher Order Functions

=== Building Intuition: Functions Ideas

=== Functions and state

=== Function refactoring

=== Function composition

=== Example Questions

==== Swap two numbers in place

==== Refactor this function

==== “Program to an interface, not an implementation”

=== Recursion

In the course of my career I've written a _lot_ of recursive code, and all of it has one thing in common: it's been some kind of exercise.  
I've been in a class and given a problem to be solved with recursion, I've been writing an exam and I promised there would be a problem that required recursion, or I've been in an interview and asked to solve a problem using recursion.

In that same span of time I don't think I've ever written a single line of recursive code in a production environment.
It's hard to come up with, hard to maintain, and if you get it wrong it can end up creating a heck of a lot more problems than it solves.

So is recursion a useful concept?
Or should it be left to academia and otherwise avoided?

The simple answer to that question is: yes!

While it's rarely the best tool for the job, recursion is a very useful concept in terms of gaining a deeper understanding of how code works.
It's an absolutely invaluable way to reason about problems.
The process used to come up with recursive solutions is identical to the process used to break larger problems into smaller, more manageable pieces.

I was a musician as a youth, and even though I always played rock songs, I worked with a teacher who taught me jazz.  
I loved it because playing jazz focused more on finesse, improvisation, and a broader musical understanding.  
When I got together with band band and we played rock, it was a lot easier to play those songs because I had a deeper understanding of music.  
(That's not a value judgement by the way.
I'm not saying either is "better."
Plenty of people hate jazz, and while I think they're making a huge mistake, I get it.)

It's the same with recursion.  
Understanding how to break a problem down in the way that's required to come up with recursive solutions is an invaluable skill for a programmer to have, even if you never use recursion in a production environment.  
That's _why_ it's focused on so much in academia and in coding interviews -- it's a way to show an advanced understanding of ways to reason about code.




=== Introduction to Recursion

=== The Elements of Recursion

=== Base Case	

=== Recursive Case

=== Reasoning about Recursion

Back in chapter 4, we discussed permutations, and I showed you a simple iterative solution for coming up with all the combinations of a set of items in an array.
Then in chapter 6, we discussed stacks and queues, and I showed you how you can use one to more effectively solve the permutations problem.
Now we're in chapter 11, and it's time to discuss how to use recursion to generate every combination of items in an array.
First, the code:
[source, python]
----
def permute(arr):
    result = []
    _permute_helper(arr, 0, len(arr) - 1, result)
    return result

def _permute_helper(arr, left, right, result):
    if left == right:
        result.append(arr.copy())
    else:
        for i in range(left, right + 1):
            arr[left], arr[i] = arr[i], arr[left]  # Swap
            _permute_helper(arr, left + 1, right, result)
            arr[left], arr[i] = arr[i], arr[left]  # Swap back
----

Here's another example from chapter 7, where I talked about heaps.
In that chapter I showed an example of the heap "bubble up" operation as a while loop.  

[source, python]
----
def _bubble_up(self, index):
    current = index
    parent = self.get_parent(current)
    
    while current > 0 and self.heap[current] > self.heap[parent]:
        # Swap current with parent
        self.heap[current], self.heap[parent] = self.heap[parent], self.heap[current]
        # Move up the heap
        current = parent
        parent = self.get_parent(current)
----



It stands to reason that once an item has been bubbled up, if it's larger than it's parent it can simply be bubbled up again.  
In this example, the while loop is replaced by a recursive call to `_bubble_up`:

[source,python]
----
def _bubble_up(self, index):
    parent = self.get_parent(index)
    
    if index > 0 and self.heap[index] > self.heap[parent]:
        self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
        self._bubble_up(parent)
----


==== When you (might) have a recursive pattern

==== When is it time to use recursion

==== Don’t paint yourself into a corner!

=== Example Questions

==== Factorial

==== Fibonacci

==== Making Change

==== Reversing a String

