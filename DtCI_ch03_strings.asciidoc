[[DtCI_ch03]]

== Strings

While this book assumes you've had an introduction to computer programming, this chapter and the next will contain an exploration of some basic computer science concepts in order to create a baseline of understanding for the content to follow.
If you come across something in this chapter that you already know feel free to skip ahead.

=== Strings

Strings are (of course) one of the most commonly used data structures in programming. 
The documentation of most programming languages starts with the ubiquitous "Hello World" program, which usually involves rendering a string. 

In Python, for instance, all that's required to render text to the console is a simple `print` statement:

`print("Hello World")`

What a great 10-character example! 
Or is it 11? 
13? 
Something else? 
To understand how to manipulate strings, you must begin by understanding the way in which they're constructed and represented by computer operating systems and programming languages.

==== Breaking Down a String

In most programming languages a string is nothing more than an array with a character at each position.

image::images/ch_03/string_as_array.png["String as Array of Characters"]

Arrays are covered in the next chapter, but let's begin by discussing what is meant by a "character."
If you're already familiar with this subject, please feel free to skip this section.

Whenever you press a key on your keyboard, like I'm doing to write this book, a character comes out on the other end.
Without going into too much detail on exactly what happens during this process, the electrical signal generated by the key is sent to the operating system, which then uses a character "lookup table" to look up the character represented by that signal.
The two most commonly used lookup tables for computers that use Latin-character-based languages (like English) are ASCII and Unicode. 
Again, there are piles of documents written about these two systems and others, and if you're interested a quick web search will show you more than you ever needed to know about these two systems.

The positions of the characters in this table are direct descendants of the teletype systems that were widely in use in the middle part of the 20th Century.
If you're watching a movie and you see a chattering machine spitting out the latest news or a top-secret message that needs to be seen immediately by the people in charge onto a sheet of paper one line at a time, that's a teletype machine.
It might be hard to imagine, but not all that long ago computers were only able to output to printers and not screens.

The size of a character in most operating systems is based on a byte.
A byte contains eight bits. 
A bit is a symbol that can contain a one or a zero.
Since each bit can represent two states, the number of signals that can be represented by a given number is bits is 2^n, where n is the number of bits.

For instance, 2 bits can represent 2^2, or 4 discrete states: [0, 0], [1, 0], [0, 1], and [1, 1]. 
Three bits can represent 2^3 or eight discrete states. 2^4 is 16 states, 2^5 is 32 states, etc.
While there are leetCode questions that cover binary numbers, they're beyond the scope of this book.
There are piles of information available that cover computer operating systems and binary mathematics, and if you have more of an interest in the subject I encourage you to look them up.

A byte, which contains eight bits, can represent 2^8 or 256 discrete states, and so most character systems are based on a representation of 256 characters.
Usually, the first 128 of these characters are usually reserved for "regular" keys on a keyboard, while the second 128 are reserved for "special" characters.
So when you press that 'd' key on your keyboard, it sends a numeric symbol to the operating system which then looks up which character is represented by that number. 
In the case of an English keyboard, the lowercase 'd' is represented by the decimal number 100.
(This is not the same as the uppercase 'D', which is represented by the number 68.)

There's nothing special about the positions of these characters. 
If you grew up speaking a language other than English, you've probably used a keyboard where the characters are in different positions than they are on an English keyboard.
That same 'd' key on a different keyboard might instead stand for "M", or "7", or "Ü", or "α".
It all depends on how the keys are mapped in that lookup table. 
The reason why should be clear: it's easier to change a look-up table than it is to rebuild a keyboard!

So when computer programmers talk about "characters," this is what is meant.
A series of symbols mapped to a lookup table, that translates them to the corresponding electrical signal represented by a keyboard key.
None of that is likely to come up as an interview question, but it's a basic idea that it's important to understand as a developer.

Another important thing to know is that not all characters are visible characters. 
The "space", "tab", "return", and "enter" (not always the same as return!) characters -- and others -- are mapped to the lookup table the same as visible characters, and have to be accounted for when you're parsing strings.
These characters are sometimes called "escape" characters since they can only be represented in strings using a symbol preceded by the character "\".
A "tab", "space", and "newline" are meaningful symbols to many programming languages and so you can't always just type them into a string.  
Instead you must type a tab character as "\t".
A return is "\r", newline is "\n", even a space must sometimes be escaped as "\ " to mean a string as a character and not a symbol that a programming language needs to consider.

These are all things to keep in mind when you hear the word "character."
When you hear the phrase "array of characters" you should immediately think of a string, and vice-versa.
And when you think of either you should picture that array as potentially containing the visible and non-visible characters that can be found in a table stored somewhere in the operating system.

Here's another look at that image above one more time:

image::images/ch_03/string_as_array.png["String as Array of Characters"]


==== Accessing a String

As mentioned before, usually the first thing a programming student is shown how to do is generate output using some kind of variation of a "print" statement.
You won't be asked interview questions about that.
What you might be asked questions about, however, is the ways in which you can manipulate strings to get the results you need to accomplish the task you want.

I recently was working for a client that needed data parsed from an Excel document to the web.
Among many of the things complicating this task was that we on the programming team had no control over what was in the Excel document.
This means that many of the cells in Excel were "polluted" with data that kept our program from running properly.

For instance, many of the cells contained line returns, or the "\n" character.
This interfered with our program, because when we wanted to put a piece of data into a specific place if we printed it with the line return it would knock all of the data following out of alignment.
I used the Python Panda's `strip()` command to get rid of these unwanted characters, but even this was limited in its effectiveness as it only considers items at the beginning and end of a string.
The team eventually had to use some custom lambda functions to get the results we wanted.
Parsing string data is absolutely something you will do more than once in your programming career.

==== Typecasting

Everyone knows that 2 + 2 = 4, but while that's fine for English or mathematics, that's not necessarily the case at all when it comes to programming languages.
For starters, "=" is the assignment operator, which means that 2 + 2 = 4 will return an error.
Additionally, do you as a programmer mean the _expression_ 2 + 2 = 4 or do you mean the _string_ "2 + 2 = 4"? 
Notice that one is in quotes and the other is not, because one is a string and the other is not.  

Context is important in computer programming.
Compilers really can't be bothered trying to figure out what it is you, the programmer, are _trying_ to do.
They don't care.
They're literal, and logical.

If you're trying to evaluate whether 2 + 2 = 4, the correct expression is:

`2 + 2 === 4`
`True`

Enter `"2" + "2" === 4` however, and what seems true is now false.

>>> "2" + "2" === 4
False

The reason for this is that like most programming languages, Python treats strings and symbols separately.
2 without quotes is the "symbol" for 2.
It means the number 2 which is exactly what you think it means.
2 fingers, 2 sisters, 2 dollars.

"2" is the string representation of 2, which doesn't mean anything to Python except that it's a string.



==== Built-in String Functions

Most programming languages contain a number of functions for manipulating strings.
One of the more basic and widely used is the "concatenation operator," which connects one string to another.

`myVar = "Hello" + "world!"`

The plus in this instance does not mean addition, it means concatenation, or joining together.
Eagle-eyed readers may have noticed that this concatenation may have an unwanted result.

`print(myVar)`
`HelloWorld!`

Oops!  
Where did the space go?
There are multiple ways to account for it, including adding it to the first or second string in the concatenation, but the object here is to make you aware that you need to account for it when processing your data.

Processing strings is an important part of data science, and so knowing how to do it is a fundamental skill all programmers must possess.
As such, you absolutely should know how at least the basics of string processing, and the built-in functions most languages contain.
Built-in string functions are also a great place to start building up your programming interview skills, as knowing how to build each of the following functions from scratch will help you gain a lot of skill in string and character processing.

While these functions may differ in name from language to language, they're all available to you as a programmer interested in manipulating strings:

`length()` or `len()` or `sizeof()` These are different names for functions that return the length of the array that is passed to them.
This is incredibly useful for processing strings because it allows your code to handle strings of whatever size is passed to it. 


[source, python]
---
myVar === "Hello world!"
print(len(myVar))
12
---

`toUpper() or toLower()`

These functions will change every character in a string either to upper or lower case, as the function name suggests.
This can be invaluable for data entry.


`split()` This function will split an array element into pieces according to a delimiter. 
When the delimiter is left empty, every element of the array will be split into an element of its own.
This function has different implementations, depending on the language, so examples of splitting strings into individual characters in different languages are shown below. 
The {cpp} standard libraries don't have a straightforward way to accomplish this task, and the easiest way to do this in Java uses a regular expression, so if you're focused on those languages you will have to either look up these implementations, or, better yet, build your skill by writing your own!

Python:

----
myString = "algorithms"
print([*myString])
# Prints ['a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 's']
----

JavaScript:
[source, javascript]
----
console.log("algorithms".split(''))
// Prints ['a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 's']
----

`splice()`  This function allows you to choose a very specific part of a string, selected by an index.

[source, python]
---
slice()
slice(start)
slice(start, end)
slice(start, end, step)
---

In languages that implement `splice()`, the data is returned without modifying the original.
This can be useful as a "stripping" operation, say to remove a line return and dollar sign from the beginning of every string in a group of strings.
Python contains the most robust splicing function, allowing programs to choose by an index that can be passed in a number of useful ways.

Be careful when using these functions as they all work slightly differently, and the difference usually has to do with how the range of items is chosen.
For example, in Python, you can use a ":" to select the range of the items you're interested in.  Arrays start at 0, and the second value in a splice parameter is the item _before_ the one in the number.

[source, python]
---
>>> myVar = ["turtle", "gecko", "frog"]
>>> myVar[1:2] # select from position to before position 2
['gecko']
>>> myVar[:3] # select everything before position 3
['turtle', 'gecko', 'frog']
>>> myVar[:2] # select everything up until position two
['turtle', 'gecko'] 
>>> myVar[2:] # select everything after position 2
['frog']
>>> 
---



There are more concepts that are applicable to strings that will be discussed in the upcoming section on arrays, including `slice()` and `reverse()`.

[NOTE]
======
Modifying data
======


I will revisit the construction of some of these functions in the upcoming "Arrays" chapter, but hopefully this has helped you start to see the importance of these basic string manipulation problems and why they might come up in programming tests. 

==== Example Questions

These next few example questions will give you a taste of what's coming in the "Searching, Sorting, and Manipulation" part of this chapter.
Try to solve the following problems without looking ahead to that section.
Or, if you get really stuck, come back and solve these problems after reading the next section.

====== Finding a Character or Word in a String

_Create a function that takes a string and a character and returns the position of that character in the string. 
For instance, given the string "One tall house, one tall ladder" and the character "a", the function would return 4. 
Notice that there are three "a"s in the string. How would you return the positions of all of them?
Does your function account for capital and lower-case letters?_

_Similarly, create a function that takes a string and returns the position of a word.
Given the same string as above, find the position of the word "tall."
Again, as above, account for the fact that there is more than one instance of "tall" in the string.
What if the word you're given is part of a larger word? The word "add" can be found inside the word "ladder."
Does your algorithm work for the cases in which this is and isn't a valid solution to the problem?
Can you think of any other things that should be considered in solving this problem?_

====== Reversing a String Without `reverse()`

_Write your own function to reverse a string. For instance, if passed the string "apple," the function should return "elppa" Can you do the same for a sentence, turning "Look at the moon" into "moon the at look?" Again, can you think of any other conditions that should be considered?_

====== Palindromes

_A palindrome is a string of text that contains the same characters in the same order both forwards and backward, excluding spaces and punctuation.
A simple example is the word "level", but the sentence "Evade, Dave!" is also a palindrome because without the capitalization, comma, space, and exclamation point the letters are "evadedave" which are the same forwards and backwards.
Write a function that determines whether or not a given string is a palindrome. If you get it working with the example given, search the internet for other examples of palindromes to test your function._



** Consider adding coding questions to the end of sections **


====== Reversing

Reversing

==== Sliding Windows

This one comes up a lot, good basic technique to know.

==== Example Questions

Here are some example questions 

====== Maximum and Minimum Element

Given an array, can you return the highest or lowest element according to a given criteria?

Example: What is the largest number in the array [7, 2, 8, 6, 5]?



====== Longest Substring Without Repeating Characters 

Given a string s, find the length of the longest 
substring
 without repeating characters.

 

Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

====== Food for Further Thought

Look up the Rabin-Karp algorithm for finding a substring in a string.  This is an algorithm you probably use all the time, like when you press CTRL-F to find text in a longer document.  The Rabin-Karp algorithm works by converting the substring to a hash value which allows it to run in O(1) time. Hashes will not be covered until Chapter 8, but try to begin thinking about Rabin-Karp now.  Is it a suitable algorithm to be used in a coding interview? Why or why not?

