[[DtCI_ch10]]

== Graphs

The graph is the data structure most single-handedly responsible for the creation of tech billionaires.  
Graphs lie the core of social networks, search engines, map applications, dating apps, recommendation engines, and even the web itself.
Graphs are a simple concept with myriad uses.
In fact, when I was a boy, my grandmother embroidered me a pillow that said "Master graphs, and you'll never want for work."
And she didn't even own a computer!

=== Graph Definition

Graphs are used to represent relationships between things.  
In computer science, a graph is represented by nodes and edges, sometimes also called vertices (singular: vertex) and arcs.
Nodes are the points in the graphs, the things that are related.
Edges are the connections between the nodes, the thing that brings them together.  

The simplest example is that everyone has a mother and a father.
But they done become mothers or fathers until they have children.  
In a human family tree, the nodes are the people and the edges are what unites the people.  
People can be connected in many ways, some temporary and some permanent.  

Outside of immediate family, people can alway be connected as friends, classmates, or co-workers.
Some people might have strong connections in this regard, strong enough that they be "married" or even "bffs."
Some people might even have negative connections, like an enemy or an ex.

I was born, so I have a mother and a father.
(As of the time of this writing, there's not really any other way to do that.)
But I was also adopted at birth.
I would not recognize my birth mother if she came to the door and tried to sell me a vacuum cleaner.  
I do know the mother and father who raised me, and I have a very close connection to them, but not a biological one. 
In fact, the only biological relative of mine that I have ever met is my son.

Here is what all of that crazy inter-personal complication might look like as a graph:

// IMAGE OF CRAZY INTER-PERSONAL COMPLICATION AS GRAPH TK

Notice that some of these relationships two way, and some are one-way.  
My son is my son, but I'm not also his son.
My BFF is my BFF, but I'm not his BFF (how sad!).
But my brother is my brother, and I'm his brother.
My wife is my spouse, and I'm also her spouse.

Also notice that some connections are stronger than others.  
My connection to my son is inviolable, but my connection to my BFF is not.
My connection to my brother is strong, but not as strong as my connection to my son.
My connection to my birth mother is pretty weak.

In a graph, the strength of the connection is called the "weight" of the edge, which is a very important concept to which I shall return. 

=== Building Intuition: When to use a graph?

At the level for which this book is intended, if you are asked about using a graph during a coding interview, it's going to be for a very specific reason.  
You're either going to be interviewing for a job where graphs are used a lot, or the interviewer is going to be testing the high-end of your knowledge.
If it's the former, you're likely not learning anything new in this chapter.
It it's the latter, expect that the interviewer is not going to expect a deep dive.  
I can't guarantee any of that, of course, but I'd be willing to give you odds I'm right.  

One suggestion I have: stick to the general.
Unless you're absolutely confident about your knowledge of graphs, paint the picture with a very broad brushstroke.  
Start with the definitions and show understanding.

Of course, if there's a coding problem that comes up and you know the answer is a graph and the code is dancing before your eyes as you respond, hey, go for it!

=== Graph data structures

This next section will cover the representation of graphs in code.
Most languages do not come with a built-in "graph" keyword or data structure, and so they have to be built using other data structures.
Graphs are primarily represented in code in one of two ways, as a matrix, or as an adjacency list.  
I'm going to start with the matrix first because even though it can present more of a challenge to manipulate, it's a lot more intuitive to look at.

.Back to math class
****
Matrices are another subject I slept right through in my high-school math classes.
I could not, for the life of me, figure out why it mattered at all for me to understand them.
A matrix is nothing more than a rectangular array of numbers.  
A spreadsheet is a matrix. 
For that matter, so is a tic-tac-toe board.
Mathematicians have come up with very clever ways to manipulate matrices, and that's all the boring stuff I slept through.  

Never fear, because now that I'm older and at least a little bit wiser, I can see matrix addition and multiplication for what it is: a series of algorithms that can be used to manipulate matrices.

You might be programming a game that features a cool alien space ship that needs to move around the screen.  
The graphic representation is a matrix of pixels.  
You could come up with graphic representations of the ship at every potential angle of representation, but if you know how to move matrices around, you can just rotate the matrix of pixels instead.

For a programmer, just learning some basic matrix math can take you a long way in terms of manipulating matrices, which means manipulating graphics, graphs, data, and all kinds of other things.  

Knowing matrix math also brings all kinds of interesting algorithmic treatments into play.
If you are trying to figure out whether it's possible in a graph to move from point A to point B, you can use matrix math to do that.
You don't have to just put a finger down and trace the path.  

****

Matrices (plural for matrix) are commonly represented as two-dimensional arrays.
The should not come as too much of a surprise.  

// DIAGRAM OF MATRIX TK

A two-dimensional array is a collection of arrays.
all of the values that run across are called "rows" and all of the values that run down are called "columns."
For example, consider this matrix:

[source, python]
----
mystery_matrix = [
    [    0,     1,    1,    0,    0,    0  ],  
    [    0,     0,    1,    0,    0,    0  ],  
    [    0,     0,    0,    1,    1,    0  ],  
    [    0,     0,    0,    0,    1,    1  ],  
    [    0,     0,    0,    0,    0,    0  ],  
    [    0,     0,    0,    0,    0,    0  ]  
]
----

Think for a moment about wha this matrix might represent.
It could be the walls to a maze in a video game.  
It could be a graphic representation of a bolt of lightning. 
It could be a social media or recommendation graph.

It's actually food web, or a diagram of "who eats whom" in an arctic food chain.
Here is is again with some comments added:

[source, python]
----
# Food Web Matrix (Binary Relationships)
# 1 = Species A (row) is eaten by Species B (column) 
# 0 = No direct predation
food_web = [
    #  Algae  Krill  Fish  Seal  Orca  Bear
    [    0,     1,    1,    0,    0,    0  ],  # Algae    - Primary producer 
    [    0,     0,    1,    0,    0,    0  ],  # Krill    - Primary consumer
    [    0,     0,    0,    1,    1,    0  ],  # Fish     - Secondary consumer
    [    0,     0,    0,    0,    1,    1  ],  # Seal     - Tertiary consumer
    [    0,     0,    0,    0,    0,    0  ],  # Orca     - Apex predator
    [    0,     0,    0,    0,    0,    0  ]   # Bear     - Competes with orcas for seals
]
----

Rows in a matrix are what goes across, from left to right.  
The first row in this matrix is also the first array, `[0, 1, 1, 0, 0, 0]`.
The row represents algae, or, more specifically, what eats algae.

Columns in a matrix are what go up and down, from top to bottom.  
The first column in this matrix is the value of the first item in each array in the matrix, `[0, 0, 0, 0, 0, 0]`.  This row also represents algae, or, more specifically, what algae eats.

Don't forget that this is a representation of a matrix in code form.  
If this was being used in a math class or on a spreadsheet, there would be no "arrays" or comma separation involved.  
This is what is known as "matrix notation" of a graph, in code form.
Yep, it's a graph and a matrix and a 2d array and a representation of a food web.  
All of that, all at the same time.
Spend a moment pondering that, let it wash over you in waves, enjoy it.

That's the matrix and more intuitive representation of a graph, but if you've ever worked with 2D arrays you know they can quickly become unwieldy.
The adjacency list is a more efficient way to represent a graph, and it is the most common way to do so in code.
Here is an example of the food web matrix as an adjacency list:

[source, python]
----
# Food Web Adjacency List
food_web = {
    'Algae': ['Krill', 'Fish'],
    'Krill': ['Fish'],
    'Fish': ['Seal', 'Orca'],
    'Seal': ['Orca', 'Bear'],
    'Orca': [],
    'Bear': []
}
----

Instead of a 2D array, the adjacency list is a dictionary, or hash table.  
All of the species are listed as keys, with the values being an array of the species that eat them.  
This form provides two immediate advantages over the matrix form:

1. It's easier to work with, since items can be accessed by keys instead of grid coordinates.

2. It's more efficient, since it only stores the relationships that exist.  No need for a "0" value -- if there is no relationship then it's simply not on the list.  

For the rest of this chapter we will only be dealing with adjacency lists.
The matrix form is still important and I will still reference it, but all of the code will be written for adjacency lists.


=== Graph Properties

There are a few basic terms that will be used throughout this chapter to describe the properties of graphs.  
There are more, but these are the most common and the most important.  

==== Graph Directedness

Graphs can be described as either "directed" or "undirected."
In a directed graph the edges have a direction, and in an undirected graph, they don't.  
That's a distinction with a very big difference, and it's important to understand.

<Image of directed vs undirected graph TK>

The family tree graph is a directed graph.  
In a family tree graph the edges are directed from older generations to younger, from parents to children, from ancestors to descendants.
It's literally impossible for the graph to flow the other way.  
The son will never be the father of his father, and the daughter will never be the mother of her mother.
It just can't happen.  

An example of an undirected graph is a social network.  
Frank will be friends with Ben, and Ben will be friends with Frank.
There is no "direction" to this friendship, it can go either way.  
In a social network, therefore, the edges are undirected.  
(Yes, there are certainly such things as "one-sided" friendships, and we'll talk about that a little later in the chapter, but for now we're talking about normal, healthy, bi-directional friendships.)

==== Ordinality

Graph ordinality is a measure of how many edges are connected to a node.  
While most graphs will have some kind of very high upper limit on the number of edges that can be connected to a single node, in some graphs the limit might be small.  
It's unusual, for instance, for a single intersection a city to be connected to more than four roads.  
It's unusual (although not impossible) for a child to have more than two parents.
Most people have only one spouse, one best friend, and one mother.  

<Diagram of graph with ordinality TK>

Ordinality might also be called "degree," and it's an important concept that we will return to later in the chapter.

==== Cyclicity

In a graph a "cycle" is a path that starts and ends at the same node.  
This could be as simple as a node that points back to itself, like an escalator or a revolving door, or it could be a complex path through hundreds or even thousands of nodes, but it always ends up at the same node where it started.

A graph that contains a cycle is called a "cyclic graph," and a graph that does not contain a cycle is called an "acyclic graph."
A tree is an example of an acyclic graph, and a family tree is a good example of such a tree.
Children do not return back to become their parents, for instance.

(Image of cyclic vs acyclic graph TK)

==== Weight

Remember when I mentioned "one-sided" friendships?
In a social network, some friendships are stronger than others.
I have some people who have been my friends for decades, and I have some friends who I have never even met in person.
To indicated the strength of a friendship I might assign a "weight" to the edge that connects the two nodes.
The weight of an edge is a measure of the strength of the relationship between the two nodes.

In a family tree, the weight of the edge might indicate whether a connection is by blood or by marriage.  
Or maybe how close one relative is to another by blood.
In a city map, the weight of an edge might be used to indicate traffic conditions, the number of lanes or speed limits on a road, or even the number of traffic lights.
In a social network the weight of an edge might indicate the strength of a friendship.
You might be friends with a celebrity, and maybe you've seen all of their movies and have their poster on your wall, but that doesn't make you their friend in real life.  
The weight of the edge between you and the celebrity might be very high, but the weight of the edge between the celebrity and you will almost certainly be low.

=== Reasoning about graphs

=== Types of graphs

==== Depth First Graph

==== Breadth First Graph

==== Weighted Graph

=== Dijkstra’s algorithm

I have to open this chapter by pointing out that Dijkstra's algorithm was not invented by Lenny Dykstra.  
He may have batted .355 for the Phillies in 1990 but he was certainly no Moe Berg.  
(I included that joke for the ten people who will get it and I will stand by it for as long as I draw breath.)

He also spelled his last name different than Esther Dijkstra, the Dutch computer scientist who actually did invent the algorithm.


=== Example Questions

==== The Königsberg Bridge / Traveling Salesman Problems

While these are unlikely to come up in a coding interview, The Königsberg Bridge and Traveling Salesman problems are graph theory classics, and can be used to explain a lot of graph theory concepts.

The Königsberg Bridge problem was of particular interest to Leonhard Euler (rhymes with "boiler," and not "ruler"), a Swiss mathematician who lived in the 18th century.  Euler was one of these mathematicians who was so brilliant that he was able to solve problems that no one else could even understand, and in some cases many people still can't understand.

<Image of the Königsberg Bridge problem TK>

It's a simple problem, really.  
Given this map of the city of Königsberg, can you find a path across all seven of Köenigsberg's bridges without crossing any of them more than once?

You can't, but explaining exactly why, mathematically, is a little more difficult.







==== Shortest path

==== Longest path

==== Fastest Path

==== Knight walk

==== Flood fill
