[[DtCI_ch04]]

== Arrays

Chapter into here

=== Arrays

Let's begin with the simplest linear data structure, the array. In less abstract languages like C++ or Java, arrays are manipulated directly from their addresses in computer memory by pointers. For our purposes, we will only consider arrays as being manipulated and addressed by the abstraction known as the array's "index."  I mention this abstraction as something to keep in the back of your mind when you consider the original purpose of some of the data structures and operations you're about to encounter. 

.Levels of Abstraction
****
Programming languages can be categorized by levels (or layers) of abstraction, which means abstraction away from the underlying hardware and chipset that a computer uses to store data and instructions. "Low-level" languages, like assembly, are only one level of abstraction from the hardware that makes up a computer, and can be used to manipulate a computer's hardware directly using what is known as "machine code." 

Low-level languages tend to make more sense to computers than humans, though, and it was realized long ago that abstractions were needed to connect human thinking and language to computer actions. "High-level" languages, like C++, take human-readable language and compile it into machine code instructions that can be used to manipulate a computer's chipset directly. There's a higher abstraction than this though. "Interpreted" languages, sometimes referred to as "scripting languages", contain an even higher level of abstraction, as these languages don't interact with the computer chipset at all. Scripting languages are instead fed to an application, like a web browser, that attempts to "interpret" their instructions into machine code. It's well worth your time to understand layers of abstraction as a programmer, and it goes far beyond what can be explained in a single side note.
****


==== Array Terminology

Arrays are close in equivalence to what is known in mathematics as a "set." 
A set is a list of items that have some relation to one another, that can be represented by a single notation. 
In strongly typed languages, arrays can only contain the same type of data, but in weakly typed languages, arrays can contain mixed data types. 
Arrays have some special terminology related to their specific use:

Element, index, set

<diagram of an array>
We looked at a simple example of an array in the last chapter, with an image showing how an array is a string of characters.

GRAPHIC:
['H', 'e', 'l', 'l', 'o', '\s', 'w', 'o', 'r', 'l', 'd', '!', '\n']
[ 0,   1,   2,   3,   4,    5,   6,   7,   8,   9,   10,  11,  12 ]


In their original versions, and as is still the case in languages like {cpp}, arrays worked hand-in-hand with data "pointers", or reference objects that "point" to specific memory addresses. 
Once an array is created in {cpp}, the programmer can "dereference" each address in memory to get the value stored there. 
Because a pointer points to a specific type of data, incrementing a pointer moves it in memory the length of that piece of data. 

In {cpp}, for instance, an integer usually (but not always!) occupies four bytes of memory. So pointing a pointer at the beginning of an array and then incrementing it by one moves it over four bytes -- to the beginning of the next item in the array. Because this type of array manipulation has become language-specific, we're not going to use pointers in this book. We'll instead settle for array items simply being referenced by their index numbers. 

<GRAPHIC>

//// THERE IS SOME UNIVERSAL MEMORY SIZE THING BEING DESCRIBED HERE, WORTH IT'S OWN SECTION ////

The length of an array is one of its most important properties. Many array operations take the length of an array into account for their operations. Most programming languages will throw an error if you try to access an element in an array that is beyond the array's "scope," or length. 

.Weakly vs. Strongly Typed Languages
****
The difference between weakly typed and strongly typed languages comes down to how strict the language requires programmers to be when mixing data. 
In strongly typed languages, like C/C++ or Java, data mixing is not allowed without creating specific data types to support the mixing.  
In weakly typed languages, this mixing is allowed, accepted, and even encouraged!

If you've used Typescript you're used to a hybrid of both, with Typescript being a language that adds strong data typing to Javascript.
There's some controversy over whether this is desirable or should even be allowed.  
Is Typescript a useful tool or simply meant to make Javascript more palatable for coders coming from more strongly typed languages, like Java?

In {cpp} an array must be of a specific data type, and only that data type is allowed in the array. Here is an integer array in {cpp}. It can only be used to hold five integer values, no more, and no other type of data is allowed. 

`int intArray[5] = {33, 22, 11, 18, 96}`

In weakly-typed JavaScript, all different types of data can be mixed together, and the language interpreter doesn't mind at all:

`mixedArray = [33, 22, 3.15159, "hello", false]`

The reasons for these differences are logical, of course, and mostly have to do with the way memory is allocated by different programming languages.
****

==== Array Indexing/Numbering

In most programming languages, arrays are numbered from zero. This is because arrays are meant to be thought of as contiguous elements in a computer's memory, as explained in the section on pointers, above. If arrays started counting from 1, there would be space unaccounted for in that first position in the memory that exists between 0 and 1. It's the same reason why the 19th century starts in 1800. You have to account for the First Century somehow, and no one wants to be from the "Zeroeth Century."  

That means the first element in the array `testArray` is located at array position 0. If `testArray = [21, 31, 41, ...]` then `testArray[0]` is where to find 21, `testArray[1]` is where to find 31, `testArray[2]` is where to find 41, etc. 

It's not uncommon for programmers to use an "offset" variable to account for the difference in counting from 0, but I think it's pretty easy to just add or subtract 1, as needed.

[source, python]
****
someArray = []
for (int i = 0; i < someArray.length, i++):
  print "The item at position", i + 1, " is " someArray[i]
****

==== Arrays and For Loops

When I taught an introductory Java class, I used to tell my students that "arrays and for loops go together like peanut butter and jelly."  What I mean by this is that they go together well, as a for loop is one of the easiest ways to traverse through an array by index, as shown in the example just above. 

One day when I was giving this example, a student cringed and said "Ew, why would you mix peanuts with jelly?!"  
I realized this was something that was not commonly done in her culture, and that not all foods are American foods. 
So if "peanut butter and jelly" makes you cringe, please feel free to pick your own food analogy: "Rice and beans", "fish and rice," "flour and butter", or any two foods that blend together well in your mind will do. 
The point is if you have to iterate over an array (peanut butter), use a for loop (jelly)! 


==== Modifying (or not Modifying) Arrays

In strongly typed languages, arrays can't be modified in length or data type once created. 
This leads to the desired outcome of an array always being what the programmer says they are. 
For a short time in the history of computer programming, this became an undesirable thing, as the rise of web programming created a generation of programmers that didn't need or want to worry about data types in their arrays since it was the browser's problem.

In that way where all old things become new again in computer programming, there has been a recent shift towards "functional programming," which insists that programmers regain control of arrays and not simply modify them according to their moods. 
The last chapter talked about "side effects," which is modifying original copies of data in a way that can't be easily reversed.
In "pure" functional programming you should not modify an array at all, but create a new copy every time you add or remove something from it. 
This keeps the array in a certain state and ensures that past states can be re-created from older copies. 
If you've ever worked with a library like Redux you might be used to this approach.

In the programming interview, make sure you understand what you're being asked to do, and treat your arrays with intention. 
Don't just blithely and blindly push information into and out of an array without understanding the problem you're being asked to solve. 

Additionally, in some languages you can't simply copy an array, because the copy will copy not the array but will only copy its pointers. 
The pointers in the copy will continue to point to the data to which the original array was told to point. 
This means that modifying the data in the new array will modify the data in the old array, and vice-versa. This type of copy is called a "shallow" copy, as opposed to a "deep" copy. 
It's important to know which type of copying your language supports, and how to get a deep copy if you need a deep copy (or a shallow copy, if that's what you want instead).

==== Basic Array Functions

Most languages contain a library of functions for arrays and questions about these functions are fairly commonly found in coding tests. These are functions that allow programmers to modify arrays in ways that make them more useful to programmers.

As you read through these examples, keep in mind that these functions -- and really any functions -- are not created by magic. They have been added to the language by programmers trying to make their jobs easier by making the language more useful. As you read about array functions, try to think of how you might create them yourself. Or better still, create them yourself and look inside the language specification to see how the problem has actually been solved. 

Array functions fall into two general categories: modifying array data and retrieving array data. As mentioned earlier, the length of the array is important for making most of these operations work properly. 

.Arrays vs. Objects vs. Tuples vs. ???
****
In the beginning was the array, and no other data type could be used for grouping related data.

Recently many programming languages have added "objects" as primitives, which are data types where the information is relational. 
Items in an object can be indexed by more than just a number, and can actually be specifically named. 
We will explore this idea more deeply when we get into hashes in the next chapter. 
In some languages, like JavaScript, there is no "array" primitive data type -- all arrays are actually objects!    

If that's not already confusing enough, most modern programming languages, like Python, have realized the need to combine multiple data types in new and more useful ways. 
In addition to arrays, Python contains lists, tuples, and dicts, all of which are array-like data structures with specific properties for specific uses.

This book is not geared toward teaching primitive data types, so make sure you understand the different types and functions available in your specific language. 
And remember, if you don't see an array data type or function you like, you can always create your own!
****

Array modification functions include the following operations:

`length()`  Retrieve the length of the array, usually to do something else with it. Sometimes shortened to `len()`

[source, python]
----
demoArray = [1, 2, 3, 4, 5]
print(len(demoArray)) # returns '5'
----

`for` loops
Every programming language contains a function that allows for simple iteration, or "counting."
Iteration is a process that has been available in programming languages from the very beginning, as it's essential to making computers work.  


`for/in` Some programming languages -- usually the weakly-typed ones -- support `for/in` operations, which automatically consider the length of an array in iteration. 

[source, python]
----
items = ["loaf of bread", "container of milk", "stick of butter"]
for item in items:
    print(item)
----


`push() / pop()`  These functions are called different things in different languages but they are for pushing an element into the end (or beginning) of an array and for retrieving an element from the beginning (or end) of an array. 


`reverse()` Many programming languages contain a function for reversing a string. 
I showed you how to build your own reverse function in the last chapter. 
How does that solution compare to the built-in function of your preferred programming language?  
How do you know?

.Building Your Own Built-In Functions
====
Knowing how to program basic built-in functions is useful because you can see how they work and because the techniques in built-in functions usually contain processes that optimize those functions.
These functions are often added to programming languages because of how often they're used, and this means they're the basis for a lot of programming interview questions.
So download the source, dig through the source code, read the spec, reverse engineer, and figure out how to program them yourself!
====

==== Array Copying
Deep copy v. shallow copy

==== JSON (JavaScript Object Notation)


=== Array Searching, Sorting, and Manipulation

Now that you know the basics of using arrays with built-in functions, this next section will focus on essential algorithms for working with data in arrays.
Much of computer programming is about searching, sorting, and manipulating data, and many programming interviews will require you to understand the basics of how to implement these algorithms.
Even if you aren't directly asked questions about these algorithms, they are incredibly useful tools to have in your programming toolbox and they can be used to solve many different types of programming problems.

==== Sorting

Sorting is just what it sounds like: sorting data according to a given criteria.

Let's start with the most straightforward sort algorithm to understand

==== Searching

Searching is when you find an item or items in a set of data. We'll talk more about search in Chapter 12, but we can start the conversation here in our discussion of arrays.
The main differences that determine the difference in whether of not to prefer a given search algorithm is the quantity of data being searched, and whether or not that data is in a specific order to start.

To try to gain some intuition for the differences in search algorithms, consider this simple example.
Let's say you decided to go to the pound to get a puppy.
There are one hundred kennels containing dogs to choose from.
You walk past all the kennels and you see a dog you just love named "Harry."

The animal trainer who works at the pound hands you a stack of papers and says you have to find Harry's paper to take him home.
The papers aren't sorted.
Right off the bat it would clearly be easier to search through the stack if the papers were already sorted.
But stop for a moment and think about how you're going to do that?
Are you just going to page through the papers from A-H until you find Harry?
Start the search at Z?
Something else?
Would you search through the papers the same way if there were only 10?
Or 10,000?
But it's not any of those things; it's a stack of 100 unsorted papers.
So how are you going to go about finding "Harry?"
Stop and consider these questions for a moment before moving on.

Let's start with a simple search: the binary search.
You may have used this one before if you've ever played "Guess the Number."
Someone says to you, "I'm thinking of a number between one and 100 and if you can guess the number in 6 guesses or fewer, I'll give you $5.  After every guess I'll tell you if my number is higher or lower than the one you choose."
Does it matter that you're told whether or not the number is higher or lower after every guess?
Why?
How would you go about solving this problem?

Even people who have never played the game before will quickly come up with winning strategies.
It doesn't make a lot of sense to guess numbers in order because that would give you only about a 5% chance to guess the number before running out of guesses.
You're also only going to guess numbers based on the clues provided to you by the person who makes the offer.
If you guess 71, and she tells you it's going to be higher than 71, it makes no sense to guess 20 on the next turn.

The foolproof way to win this game every time is by conducting a binary search.
The reason it's called a binary search is because every guess reduces the remaining number pool into two parts, and then eliminates one of them from further consideration.

Following this strategy, your first guess should be 50.
It cuts the remaining number pool in half.


==== Sliding Windows

Many problems that involve subsets of strings can be solved using the so-called "sliding window" technique.
Just like it sounds, the technique involves moving a data "window" over a string, and collecting, analyzing, or manipulating the data in that window.

[SLIDING WINDOW ILLUSTRATION]

In languages that support them, the sliding window technique is implemented using data pointers. 
In languages that don't support pointers the technique requires the coder to create their own pointers, but fortunately that's not a terribly difficult thing to do. 
A pointer is just a variable that contains the location of another variable.  
You can think of it like this: imagine you're looking at a row of lockers.  
You can't see what's in the lockers, but you can see the numbers on the front of the lockers.  
In front of the lockers stands a robot who knows what's in each locker.
You ask can ask the robot two questions: 
  "What's in locker x?"
  "Which locker contains item x."
In this analogy, the robot is the pointer, the lockers are the array, and the contents of the lockers are data.  

You use a type of pointer when iterating over a for loop, with a variable that is usually named `i`.  

[source, python]
----
for i in range(len(arr)):
  print(arr[i])
----

In this case, `i` is the pointer that will go down the line of "lockers" represented by the array `arr`, and "open" (also called "dereference") each locker to see what's inside, returning the contents to the "print" function.  
Keep this analogy in mind as you go over the sliding window problem.  
The sliding window is literally a window -- or multiple windows -- that allow us to see what's in the lockers.  
You can assign logical conditions to these windows, and use them to solve problems that involve subsets of strings.

Example Sliding Window Problem:

_Given an array of integers, find the two adjacent integers with the largest sum._

Array: [22, 1, 21, 12, 7, 19, 9, 3, 8, 17, 2, 20]

Looking the over quickly it's not too hard to see that the two adjacent integers with the largest sum are 21 and 12, which add up to 33.

Let's start by solving this problem with a brute force solution. 
In this case, a nested for loop is great place to start.
In this solution, the variables `i` and `j` are used as the "pointers", and because j always equals `i + 1`, the sum of any two adjacent integers can be calculated by adding `arr[i]` and `arr[j]`, which comprise the two-element "window" that is moved over the array:

[source, python]
----
def largest_sum(arr):
  largest = 0
  for i in range(len(arr)):
    for j in range(i + 1, len(arr)):
      if arr[i] + arr[j] > largest:
        largest = arr[i] + arr[j]
  return largest
----

Great start, but it's not the most efficient solution.
Nested for loops should always come under consideration for optimization, as their runtime is O(n^2) -- the dreaded "quadratic."
So how can we do better?
Do we really need to use two for loops?
Can we just run that single comparison "window" over the array and get the same result?
Let's try it!

[source, python]
----
def largest_sum(arr):
  largest = 0
  for i in range(len(arr) - 1):
    if arr[i] + arr[i + 1] > largest:
      largest = arr[i] + arr[i + 1]
  return largest
----

Excellent!  We've eliminated the nested for loop, and not the runtime of the function is now the preferable "linear" time of O(n).

So that's a simple example of the sliding window technique.
Let's look at a more complicated example.
Now the interviewer asks you to find the longest substring within a given string that contains only unique characters. 
For instance, if you're given the string:

"abbcaabdcbb"

The answer is "abdc", because it's the longest substring that contains only unique characters.

Let's first try to get this with a brute force solution:

[source, python]
---- 
def longest_unique_substring(s):
  longest = 0
  for i in range(len(s)):
    for j in range(i + 1, len(s)):
      if len(set(s[i:j])) == j - i:
        if j - i > longest:
          longest = j - i
  return longest

someVar = "abbcaabdcbb"
print(longest_unique_substring(someVar))
----

This might be an example of where the brute force solution is a little more brutal than it needs to be, but I wanted to take a moment to talk about the `set()` function.
A "set" in math and logic is a group of related but distinct items, be they words, number, objects, etc. 
The days of the week are a set, as are the months of the year. 

`set()` (or `new Set()` in JavaScript) is a function that takes an array and returns one of each unique element in that array.
What's returned is probably not going to be in any kind of determined order.
For instance, here's what happened when I just ran the line of code:

[source, python]
----
>>> print (set ("abcdeabcdeabcde"))

{'d', 'a', 'b', 'c'}
----

Correct!
But why in that order?  
I don't really know, and I don't think it matters. 
Why I'm discussing it is because you might be asked about using `set()` to solve problems related to uniqueness, and sometimes it absolutely is the right tool for the job. 
In this case, however, it's not.
Can you see why?

Consider the run time of the function above. 
Using `set()` to iterate repeatedly over chunks of items in the string can be considered a third nested loop, and so the runtime of the function is now O(n^3), which is a shape I didn't even mention because hopefully you won't come across it all that often.
So if you're asked "Why didn't you use `set()`," be careful, it's a trick question!
Let's see how sliding windows can help solve this problem more effectively.

[source, python]
----
def longest_unique_substring(s):
    longest_length = 0
    start = 0
    longest_start = 0
    char_index_map = {}

    for end in range(len(s)):
        char = s[end]
        if char in char_index_map and char_index_map[char] >= start:
            start = char_index_map[char] + 1
        char_index_map[char] = end
        if end - start + 1 > longest_length:
            longest_length = end - start + 1
            longest_start = start

    return s[longest_start:longest_start + longest_length]

test_var = "abbcaabdcbb"
print(longest_unique_substring(test_var))  # Output: "bcad"
----

==== Sample Questions

===== Array Rotation

Rotate

===== Permutations

ABCDE = EBDCA